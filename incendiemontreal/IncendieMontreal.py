# -*- coding: utf-8 -*-
"""
/***************************************************************************
 IncendieMontreal
                                 A QGIS plugin
 Analyse du nombre d'individus, les adresses et les rues affectés par un incendie.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2020-03-16
        git sha              : $Format:%H$
        copyright            : (C) 2020 by David Ethier et Elizabeth Cauvier Charest
        email                : ethd2002@usherbrooke.ca; caue3201@usherbrooke.ca
 ***************************************************************************/
/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QFileDialog
from qgis.core import QgsGeometry, QgsVectorLayer, QgsField, QgsFeature, QgsProject, QgsVectorFileWriter, QgsWkbTypes, QgsCoordinateTransform, QgsDistanceArea, QgsMessageLog, Qgis
from PyQt5.QtWidgets import QMessageBox


# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .IncendieMontreal_dialog import IncendieMontrealDialog
import os.path


class IncendieMontreal:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.
        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'IncendieMontreal_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&IncendieMontreal')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.
        We implement this ourselves since we do not inherit QObject.
        :param message: String for translation.
        :type message: str, QString
        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('IncendieMontreal', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.
        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str
        :param text: Text that should be shown in menu items for this action.
        :type text: str
        :param callback: Function to be called when the action is triggered.
        :type callback: function
        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool
        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool
        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool
        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str
        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget
        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.
        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/IncendieMontreal/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Incendie Montreal'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&IncendieMontreal'),
                action)
            self.iface.removeToolBarIcon(action)


    def select_output_file(self):
        '''
        Permet de choisir un fichier de sortie (.txt). Le chemin du fichier s'affiche dans la ligne correspondante
        Appelée quand l'utilisateur clique sur le bouton de sélection du fichier de sortie
        '''

        options = QFileDialog.Options()
        options |= QFileDialog.DontUseNativeDialog
        file, _filter = QFileDialog.getSaveFileName(
            self.dlg, "QFileDialog.getSaveFileNames()", "", "*.txt", options=options)
        self.dlg.Line_sortie.setText(file)

    def chargerFichier(self, type, intrant):
        '''
        Fonction qui permet de sélectionner d'ouvrir un browser et de sélectionner un fichier sur l'odinateur
        En fonction de l'intrant et de son type (.shp, .csv) en entrée, le chemin du fichier choisi s'affiche sur
        la ligne correspondante.
        Appelée lorsque l'utilisateur clique sur un bouton de sélection d'intrant
        '''

        options = QFileDialog.Options()
        options |= QFileDialog.DontUseNativeDialog
        file, _filter = QFileDialog.getOpenFileName(
            self.dlg, "QFileDialog.getOpenFileNames()", "", "*.{}".format(type), options=options)
        if file:
            if intrant == 'recensSpat':
                QgsMessageLog.logMessage('Couche de recensement: {}'.format(file), 'IncendieMontreal', level=Qgis.Info)
                self.dlg.comboBox_recens_spat.addItem(file)
                index = self.dlg.comboBox_recens_spat.findText(file)
                self.dlg.comboBox_recens_spat.setCurrentIndex(index)
            elif intrant == 'route':
                QgsMessageLog.logMessage('Couche de routes: {}'.format(file),'IncendieMontreal', level=Qgis.Info)
                self.dlg.comboBox_route.addItem(file)
                index = self.dlg.comboBox_route.findText(file)
                self.dlg.comboBox_route.setCurrentIndex(index)
            elif intrant == 'adresse':
                QgsMessageLog.logMessage('Couche des adresses: {}'.format(file),'IncendieMontreal', level=Qgis.Info)
                self.dlg.comboBox_adresse.addItem(file)
                index = self.dlg.comboBox_adresse.findText(file)
                self.dlg.comboBox_adresse.setCurrentIndex(index)
            elif intrant == 'recensText':
                QgsMessageLog.logMessage('CSV de recensement: {}'.format(file),'IncendieMontreal', level=Qgis.Info)
                self.dlg.Line_recens_text.setText(file)



    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = IncendieMontrealDialog()

            # On appelle la fonction de chargement de fichier pour tous les intrants si le bouton est cliqué
            self.dlg.toolButton_spat.clicked.connect(lambda: self.chargerFichier(type='shp', intrant='recensSpat'))
            self.dlg.toolButton_route.clicked.connect(lambda: self.chargerFichier(type='shp', intrant='route'))
            self.dlg.toolButton_addresse.clicked.connect(lambda: self.chargerFichier(type='shp', intrant='adresse'))
            self.dlg.toolButton_text.clicked.connect(lambda: self.chargerFichier(type='csv', intrant='recensText'))
            self.dlg.toolButton_sortie.clicked.connect(self.select_output_file)


        #Clear les boîtes et lignes d'input
        self.dlg.comboBox_recens_spat.clear()
        self.dlg.comboBox_adresse.clear()
        self.dlg.comboBox_route.clear()
        self.dlg.Line_recens_text.clear()
        self.dlg.lineEdit_buffer.clear()
        self.dlg.lineEdit_buffer_2.clear()
        self.dlg.lineEdit_buffer_3.clear()
        self.dlg.Line_sortie.clear()


        # Aller chercher toutes les couches présentement dans le projet pour les faire apparaître dans le menu des box
        layers = QgsProject.instance().layerTreeRoot().children()
        # Ajouter les couches actives dans la liste des couches possibles à sélectionner
        self.dlg.comboBox_recens_spat.addItems([layer.name() for layer in layers])
        self.dlg.comboBox_adresse.addItems([layer.name() for layer in layers])
        self.dlg.comboBox_route.addItems([layer.name() for layer in layers])

        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed

        if result:
        # Récupération des informations générales du projet

            projCrs = QgsProject.instance().crs()
            projEpsg = str(projCrs).split(':')[2][:-1]

        # Récupération des données en entrées

            taille_buffer = self.dlg.lineEdit_buffer.text()
            output_name = self.dlg.Line_sortie.text()
            recens_text = self.dlg.Line_recens_text.text()
            point_lat = self.dlg.lineEdit_buffer_2.text()
            point_lon = self.dlg.lineEdit_buffer_3.text()

            recens_spat_name = self.dlg.comboBox_recens_spat.currentText()
            adresse_name = self.dlg.comboBox_adresse.currentText()
            route_name = self.dlg.comboBox_route.currentText()


            liste_intrants = [taille_buffer, output_name, recens_text, point_lat, point_lon, recens_spat_name,
                              adresse_name, route_name]

            # Fonction pour détecter les données manquantes et afficher un message conséquent à l'utilisateur
            def donneesManquantes(liste_intrant):
                # Dictionnaire des intrants du plugin. Chaque clé correspond à l'index de l'intrant dans liste_intrant
                dic_intrants = {'0':"Taille de la zone d'analyse", '1':"Fichier de sortie",
                                '2': "Fichier de recensement textuel", '3': "Latitude", '4': "Longitude",
                                '5': "Couche de recensement spatiale", '6': "Couche des adresses",
                                '7': "Couche du réseau routier"}

                listeManquant = []
                # on parcours la liste des intrants
                for i in range(len(liste_intrant)):
                    # Si la valeur de l'intrant est nulle, on va chercher son nom. dans le dictionnaire
                    if len(liste_intrant[i]) == 0:
                        index = i
                        name = dic_intrants[str(index)]
                        # Si le nom n'est pas déjà dans la liste des intrants manquants, on l'ajoute
                        if name not in listeManquant:
                            listeManquant.append(name)
                # Si la liste des intrants manquants n'est pas vide, on affiche un message des intrants manquants et retourne False
                if len(listeManquant) > 0:
                    # Affiche un message d'erreur et ajoute le message au log
                    QMessageBox.critical(self.dlg, 'Donnée(s) manquante(s)', '\n'.join(map(str, listeManquant)))
                    QgsMessageLog.logMessage('Donnée(s) manquante(s): ' + ', '.join(map(str, listeManquant)),
                                             'IncendieMontreal', level=Qgis.Info)
                    return False
                # Sinon retourne vrai
                return True



            # Si tous les intrants sont présents, on essaie d'effectuer les traitements, sinon on affiche un message d'erreur.
            if donneesManquantes(liste_intrants):
                try:

                # Création de la couche du point incident
                    couche_point = QgsVectorLayer('Point?crs=epsg:4326', 'couche_point', 'memory')
                    pointProv = couche_point.dataProvider()
                    feat = QgsFeature()
                    feat.setGeometry(QgsGeometry.fromWkt('Point({} {})'.format(float(point_lon), float(point_lat))))
                    pointProv.addFeature(feat)
                    couche_point.updateExtents()

                # Chercher les couches dans les comboBox (peuvent être une couche active ou un path vers fichier)

                    def chercherCoucheActiveOuFichier(name_couche):
                        # on vérifie si le nom de couche en entrée est une couche active ou non
                        listeCouche = QgsProject.instance().mapLayersByName(name_couche)
                        if len(listeCouche) > 0:
                            # Si oui on utilise cette couche pour les traitement
                            couche = listeCouche[0]
                        else:
                            # Sinon, on va chercher la couche au chemin en entrée
                            path = r'{}'.format(name_couche)
                            couche = QgsVectorLayer(path, "AD layer", "ogr")
                        # Retourne un objet
                        return couche

                    couche_recens = chercherCoucheActiveOuFichier(recens_spat_name)
                    couche_adresse = chercherCoucheActiveOuFichier(adresse_name)
                    couche_route = chercherCoucheActiveOuFichier(route_name)

                # Reprojection des couches selon le CRS du projet
                    def reprojectToInstanceCrs(couche_vec, type, outCrs, outName):
                        # Définition du CRS de la couche
                        inCrs = couche_vec.crs()
                        # Extraction du code EPSG du CRS du projet
                        outEpsg = str(outCrs).split(':')[2][:-1]
                        # Création d'un objet QgsCoordinateTransform
                        trans = QgsCoordinateTransform(inCrs, outCrs, QgsProject.instance())
                        # Création de la couche de sortie et de son provider
                        outputLayer = QgsVectorLayer('{}?crs=epsg:{}'.format(type, outEpsg), outName, 'memory')
                        pr = outputLayer.dataProvider()
                        # Déclaration des variables contenant les entités et les attributs de la couche en entrée
                        couche_features = couche_vec.getFeatures()
                        couche_fields = couche_vec.fields()

                        # On copie les attributs de la couche en entrée dans la couche de sortie
                        pr.addAttributes(couche_fields)
                        outputLayer.updateFields()

                        # parcours les entité de la couche en entrée
                        for feature in couche_features:
                            geom = feature.geometry()
                            # reprojection du geom de l'entité
                            geom.transform(trans)
                            # On ajuste le geom de l'entité et on l'ajoute à la couche de sortie
                            feature.setGeometry(geom)
                            pr.addFeature(feature)

                        # On met la couche de sortie à niveau
                        outputLayer.updateExtents()
                        # On affiche la couche dans le projet courant QGIS
                        # QgsProject.instance().addMapLayer(outputLayer)
                        # Retourne la couche de sortie
                        return outputLayer

                    # Pour chaque couche en entrée du plugin, on reprojette si le CRS n'est pas celui du projet courant

                    QgsMessageLog.logMessage(
                        'Reprojection des couches au SRC du projet courant...',
                        'IncendieMontreal', level=Qgis.Info)

                    if couche_recens.crs() != projCrs:
                        couche_recens = reprojectToInstanceCrs(couche_recens, 'Polygon', projCrs, 'recens_reproj')
                    if couche_route.crs() != projCrs:
                        couche_route = reprojectToInstanceCrs(couche_route, 'MultiLineString', projCrs, 'route_reproj')
                    if couche_adresse.crs() != projCrs:
                        couche_adresse = reprojectToInstanceCrs(couche_adresse, 'Point', projCrs, 'adresse_reproj')
                    if couche_point.crs() != projCrs:
                        couche_point = reprojectToInstanceCrs(couche_point, 'Point', projCrs, 'point_reproj')

                # Buffer sur le point en entrée

                    QgsMessageLog.logMessage(
                        "Création de la zone d'analyse...",
                        'IncendieMontreal', level=Qgis.Info)

                    layer = couche_point
                    feats = layer.getFeatures()

                    # création de la couche vectorielle
                    buffer = QgsVectorLayer("Polygon?crs=epsg:{}".format(projEpsg), "Zone_incident", "memory")
                    pr = buffer.dataProvider()

                    # Création du buffer
                    for feat in feats:
                        geom = feat.geometry()
                        buff = geom.buffer(int(taille_buffer), 5)
                        feat.setGeometry(buff)
                        pr.addFeature(feat)
                    buffer.updateExtents()

                # Fonction pour faire la liste des entités d'une couche qui intersect une couche de buffer
                    def entite_intersect_buffer(couche_buffer, couche_vec, attribut_a_garder):
                        couche = couche_vec
                        # Déclarer les features de la couche de buffer et d'entité
                        buff_feature = couche_buffer.getFeatures()
                        couche_feature = couche.getFeatures()

                        liste_intersect = []
                        for buff in buff_feature:
                            geom_buff = buff.geometry()
                            # On parcours les entités de la couche vec et on déclare leur géométrie
                            for entite in couche_feature:
                                geom_entite = entite.geometry()
                                # Si l'entite intersect le buffer, ajoute les attributs voulus au dic, ajoute le dic à la liste
                                if geom_entite.intersects(geom_buff):
                                    dic = {}
                                    for attribut in attribut_a_garder:
                                        if attribut == 'GEOMETRY':
                                            value = geom_entite
                                        else:
                                            value = entite[attribut]
                                        dic.update({attribut: value})
                                    liste_intersect.append(dic)
                        # retourne liste d'entités sous forme de dic avec les attributs voulus de l'entité
                        return liste_intersect

                # Aller chercher les AD qui sont affectées
                    QgsMessageLog.logMessage(
                        'Identification des AD affectées...',
                        'IncendieMontreal', level=Qgis.Info)

                    ad_affectee = entite_intersect_buffer(buffer, couche_recens, ['ADIDU'])
                    # print(ad_affectee)

                # Aller chercher la population totale affectée dans le CSV en entrée
                    QgsMessageLog.logMessage(
                        'Identification de la population totale affectée...',
                        'IncendieMontreal', level=Qgis.Info)
                    import csv
                    path_csv = r'{}'.format(recens_text)

                    dic_pop = {}
                    # on ouvre le fichier CSV des AD e spécifiant l'encodage à ISO-8859-1 pour gérer les caractères spéciaux
                    with open(path_csv, encoding='ISO-8859-1') as csv_file:
                        # On crée le reader qui va permettre de parcourir les row comme des dictionnaires
                        csv_reader = csv.DictReader(csv_file)
                        # On parcours chaque row du fichier
                        for row in csv_reader:
                            for i in ad_affectee:
                                for j in i.values():
                                    # Si le ID du row égal un ID dans la liste des AD affectées, on ajoute la pop. du row
                                    # avec son ID au dictionnaire
                                    if row['ADidu'] == j:
                                        dic_pop.update({j: int(row['ADpop_2016'])})
                    # print(dic_pop)
                    # On additionne toutes les populations du dictionnaire pour trouver la pop. totale
                    pop_totale = sum(dic_pop.values())

                # Aller chercher les rues qui sont affectées
                    QgsMessageLog.logMessage(
                        'Identification des rues affectées..',
                        'IncendieMontreal', level=Qgis.Info)
                    rue_affectee = entite_intersect_buffer(buffer, couche_route, ['CLASSE', 'TYP_VOIE', 'NOM_VOIE'])

                # Aller chercher les adresses affectées
                    QgsMessageLog.logMessage(
                        'Identification des adresses affectées...',
                        'IncendieMontreal', level=Qgis.Info)
                    adr_affectee = entite_intersect_buffer(buffer, couche_adresse,
                                                           ['ID_ADRESSE', 'TEXTE', 'SPECIFIQUE', 'GENERIQUE', 'GEOMETRY'])

                # Aller chercher l'adresse la plus proche
                    QgsMessageLog.logMessage(
                        "Identification de l'adresse la plus proche...",
                        'IncendieMontreal', level=Qgis.Info)
                    dis = QgsDistanceArea()
                    # On déclare les entités de la couche du point incident
                    featInc = couche_point.getFeatures()
                    # On parcours les entités de la couche du point incident
                    for pointInc in featInc:
                        # On déclare le geom de l'entité comme un point
                        geomInc = pointInc.geometry().asPoint()
                        # On parcours la liste des adresses affectées
                        for adr in adr_affectee:
                            # On déclare le geom de l'adresses affectées comme un points
                            geomAdr = adr['GEOMETRY'].asPoint()
                            # On calcule la distance entre le point incident et l'adresse affectée
                            distance = dis.measureLine(geomInc, geomAdr)
                            # On ajoute la distance comme attribut dans le dictionnaire de l'adresse
                            adr['DIST'] = distance

                    # On tri la liste des adresses affectées selon la distance
                    sort_adr_aff_distance = sorted(adr_affectee, key=lambda i: i['DIST'])
                    # On récupère l'adresse ayant la distance la plus courte
                    adr_plus_proche = sort_adr_aff_distance[0]

                # Afficher les informations dans la console
                    # Population totale
                    print('La population totale affectée est de : {} personnes'.format(pop_totale))

                    # Rues affectées
                    liste_rue_unique = []
                    for rue in rue_affectee:
                        if rue not in liste_rue_unique:
                            liste_rue_unique.append(rue)
                    sort_rue_aff = sorted(liste_rue_unique, key=lambda i: (i['CLASSE'], i['NOM_VOIE']))
                    print('Les rues affectées sont:')
                    for r in sort_rue_aff:
                        print('nom: {}'.format(r['NOM_VOIE']), 'Type: {}'.format(r['TYP_VOIE']))

                    # Adresse la plus proche de l'incident
                    print("L'adresse la plus proche de l'incident est: {} {} {}"
                          .format(adr_plus_proche['TEXTE'], adr_plus_proche['GENERIQUE'], adr_plus_proche['SPECIFIQUE']))
                    print('Distance: {:.2f} m'.format(adr_plus_proche['DIST']))

                # Création du fichier de sortie
                    QgsMessageLog.logMessage(
                        "Création du fichier de sortie {} ...".format(output_name),
                        'IncendieMontreal', level=Qgis.Info)
                    f = open(r'{}'.format(output_name), 'w')

                    f.write('****************************************************\n')
                    f.write("RÉSULTATS DE L'ANALYSE DE L'OUTIL'INCENDIEMONTREAL'\n")
                    f.write('****************************************************\n')
                    f.write('\n')

                    # Paramètres en entrée
                    f.write('Latitude: {}°\n'.format(point_lat))
                    f.write('Longitude: {}°\n'.format(point_lon))
                    f.write("Taille de la zone d'analyse: {} m\n".format(int(taille_buffer)))
                    f.write('\n')

                    # Population totale
                    f.write('La population totale affectée est de : {} personnes\n'.format(pop_totale))
                    f.write('\n')

                    # Adresse la plus proche de l'incident
                    f.write("L'adresse la plus proche de l'incident est: {} {} {}\n"
                            .format(adr_plus_proche['TEXTE'], adr_plus_proche['GENERIQUE'], adr_plus_proche['SPECIFIQUE']))
                    f.write('Distance: {:.2f} m\n'.format(adr_plus_proche['DIST']))
                    f.write('\n')

                    # Rues affectées et adresses
                    count = 0
                    f.write('Les adresses affectées ainsi que leur rue respective sont:\n')
                    f.write('\n')
                    for r in sort_rue_aff:
                        f.write('NOM: {} TYPE: {}\n'.format(r['NOM_VOIE'], r['TYP_VOIE']))
                        for a in adr_affectee:
                            if str(a['SPECIFIQUE']).lower() == str(r['NOM_VOIE']).lower() and str(a['GENERIQUE']).lower() == str(
                                    r['TYP_VOIE']).lower():
                                f.write('{} {} {}\n'.format(a['TEXTE'], a['GENERIQUE'], a['SPECIFIQUE']))
                                count += 1
                        f.write('\n')

                    # Fin du document
                    f.write('\n')
                    f.write('***************************************************\n')
                    f.write('FIN DES RÉSULTATS\n')
                    f.write('***************************************************\n')
                    f.close()

                    QgsMessageLog.logMessage('Terminé', 'IncendieMontreal', level=Qgis.Info)

                except ValueError as e:
                    message = "Il y a un problème avec la valeur d'un ou plusieurs intrants: \n {}".format(e)
                    QMessageBox.critical(self.dlg, "Erreur de valeur", '{}'.format(message))
                    QgsMessageLog.logMessage(message,'IncendieMontreal', level=Qgis.Info)
                except TypeError as e:
                    message = "Il y a un problème avec le type d'un ou plusieurs intrants: \n {}".format(e)
                    QMessageBox.critical(self.dlg, "Erreur de type", '{}'.format(message))
                    QgsMessageLog.logMessage(message,'IncendieMontreal', level=Qgis.Info)
