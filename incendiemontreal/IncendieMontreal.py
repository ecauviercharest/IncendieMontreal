# -*- coding: utf-8 -*-
"""
/***************************************************************************
 IncendieMontreal
                                 A QGIS plugin
 Analyse du nombre d'individus, les adresses et les rues affectés par un incendie.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2020-03-16
        git sha              : $Format:%H$
        copyright            : (C) 2020 by David Ethier et Elizabeth Cauvier Charest
        email                : caue3201@usherbrooke.ca
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QFileDialog
from qgis.core import QgsGeometry, QgsVectorLayer, QgsField, QgsFeature, QgsProject, QgsVectorFileWriter, QgsWkbTypes, QgsCoordinateTransform, QgsDistanceArea
import processing

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .IncendieMontreal_dialog import IncendieMontrealDialog
import os.path


class IncendieMontreal:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'IncendieMontreal_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&IncendieMontreal')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('IncendieMontreal', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/IncendieMontreal/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Incendie Montreal'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&IncendieMontreal'),
                action)
            self.iface.removeToolBarIcon(action)


    def select_input_file(self):
        filename, _filter = QFileDialog.getOpenFileName(
            self.dlg, "Select input file ", "", '*.shp')
        # Add the selected filename to combobox
        self.dlg.comboBox_recens_spat.addItem(filename)
        # Obtain index of newly-added item
        index = self.dlg.comboBox_recens_spat.findText(filename)
        # Set the combobox to select the new item
        self.dlg.comboBox_recens_spat.setCurrentIndex(index)


    def select_recens_text(self):
        filename, _filter = QFileDialog.getOpenFileName(
            self.dlg, "Select CSV file ", "", '*.csv')
        self.dlg.Line_recens_text.setText(filename)


    def select_output_file(self):
        filename, _filter = QFileDialog.getSaveFileName(
            self.dlg, "Select   output file ", "", '*.txt')
        self.dlg.line_sortie.setText(filename)


    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = IncendieMontrealDialog()

        # On appelle la fonction select_input_file si le bouton toolButton_spat est cliqué
        self.dlg.toolButton_spat.clicked.connect(self.select_input_file)
        # On appelle la fonction select_output_file si le bouton toolButton_sortie est cliqué
        self.dlg.toolButton_sortie.clicked.connect(self.select_output_file)
        # On appelle la fonction select_recens_text si le bouton toolButton_text est cliqué
        self.dlg.toolButton_text.clicked.connect(self.select_recens_text)


        # Aller chercher toutes les couches présentement dans le projet
        layers = QgsProject.instance().layerTreeRoot().children()
        # Clear the contents of the comboBox from previous runs
        self.dlg.comboBox_recens_spat.clear()
        # Populate the comboBox with names of all the loaded layers
        self.dlg.comboBox_recens_spat.addItems([layer.name() for layer in layers])

        self.dlg.comboBox_point.clear()
        self.dlg.comboBox_point.addItems([layer.name() for layer in layers])

        self.dlg.comboBox_adresse.clear()
        self.dlg.comboBox_adresse.addItems([layer.name() for layer in layers])

        self.dlg.comboBox_route.clear()
        self.dlg.comboBox_route.addItems([layer.name() for layer in layers])

        self.dlg.Line_recens_text.clear()

        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:

        # Récupération des informations générales du projet

            projCrs = QgsProject.instance().crs()
            projEpsg = str(projCrs).split(':')[2][:-1]

        # Récupération des données en entrées

            taille_buffer = self.dlg.lineEdit_buffer.text()
            output_name = self.dlg.Line_sortie.text()
            recens_text = self.dlg.Line_recens_text.text()

            point_name = self.dlg.comboBox_point.currentText()
            recens_spat_name = self.dlg.comboBox_recens_spat.currentText()
            adresse_name = self.dlg.comboBox_adresse.currentText()
            route_name = self.dlg.comboBox_route.currentText()

            # Couches en assumant qu'elles sont ouvertes dans le projet
            liste_couche_point = QgsProject.instance().mapLayersByName(point_name)
            couche_point = liste_couche_point[0]
            liste_couche_recens = QgsProject.instance().mapLayersByName(recens_spat_name)
            couche_recens = liste_couche_recens[0]
            liste_couche_adresse = QgsProject.instance().mapLayersByName(adresse_name)
            couche_adresse = liste_couche_adresse[0]
            liste_couche_route = QgsProject.instance().mapLayersByName(route_name)
            couche_route = liste_couche_route[0]

        # Reprojection des couches selon le CRS du projet
            def reprojectToInstanceCrs(couche_vec, type, outCrs, outName):
                # Définition du CRS de la couche
                inCrs = couche_vec.crs()
                # Extraction du code EPSG du CRS du projet
                outEpsg = str(outCrs).split(':')[2][:-1]
                # Création d'un objet QgsCoordinateTransform
                trans = QgsCoordinateTransform(inCrs, outCrs, QgsProject.instance())
                # Création de la couche de sortie et de son provider
                outputLayer = QgsVectorLayer('{}?crs=epsg:{}'.format(type, outEpsg), outName, 'memory')
                pr = outputLayer.dataProvider()
                # Déclaration des variables contenant les entités et les attributs de la couche en entrée
                couche_features = couche_vec.getFeatures()
                couche_fields = couche_vec.fields()

                # On copie les attributs de la couche en entrée dans la couche de sortie
                pr.addAttributes(couche_fields)
                outputLayer.updateFields()

                # parcours les entité de la couche en entrée
                for feature in couche_features:
                    geom = feature.geometry()
                    # reprojection du geom de l'entité
                    geom.transform(trans)
                    # On ajuste le geom de l'entité et on l'ajoute à la couche de sortie
                    feature.setGeometry(geom)
                    pr.addFeature(feature)

                # On met la couche de sortie à niveau
                outputLayer.updateExtents()
                # On affiche la couche dans le projet courant QGIS
                #QgsProject.instance().addMapLayer(outputLayer)
                # Retourne la couche de sortie
                return outputLayer

            # Pour chaque couche en entrée du plugin, on reprojette si le CRS n'est pas celui du projet courant
            if couche_recens.crs() != projCrs:
                couche_recens = reprojectToInstanceCrs(couche_recens, 'Polygon', projCrs, 'recens_reproj')
            if couche_route.crs() != projCrs:
                couche_route = reprojectToInstanceCrs(couche_route, 'MultiLineString', projCrs, 'route_reproj')
            if couche_adresse.crs() != projCrs:
                couche_adresse = reprojectToInstanceCrs(couche_adresse, 'Point', projCrs, 'adresse_reproj')
            if couche_point.crs() != projCrs:
                couche_point = reprojectToInstanceCrs(couche_point, 'Point', projCrs, 'point_reproj')


        # Buffer sur le point en entrée
            layer = couche_point
            feats = layer.getFeatures()

            # création de la couche vectorielle
            buffer = QgsVectorLayer("Polygon?crs=epsg:{}".format(projEpsg), "Zone_incident", "memory")
            pr = buffer.dataProvider()

            # Création du buffer
            for feat in feats:
                geom = feat.geometry()
                buff = geom.buffer(int(taille_buffer), 5)
                feat.setGeometry(buff)
                pr.addFeature(feat)
            buffer.updateExtents()
            # Ajout de la couche à Qgis
            #QgsProject.instance().addMapLayer(buffer)

        # Fonction pour faire la liste des entités d'une couche qui intersect une couche de buffer
            def entite_intersect_buffer(couche_buffer, couche_vec, attribut_a_garder):
                couche = couche_vec
                # Déclarer les features de la couche de buffer et d'entité
                buff_feature = couche_buffer.getFeatures()
                couche_feature = couche.getFeatures()

                liste_intersect = []
                for buff in buff_feature:
                    geom_buff = buff.geometry()
                    # On parcours les entités de la couche vec et on déclare leur géométrie
                    for entite in couche_feature:
                        geom_entite = entite.geometry()
                        # Si l'entite intersect le buffer, ajoute les attributs voulus au dic, ajoute le dic à la liste
                        if geom_entite.intersects(geom_buff):
                            dic = {}
                            for attribut in attribut_a_garder:
                                if attribut == 'GEOMETRY':
                                    value = geom_entite
                                else:
                                    value = entite[attribut]
                                dic.update({attribut: value})
                            liste_intersect.append(dic)
                # retourne liste d'entités sous forme de dic avec les attributs voulus de l'entité
                return liste_intersect

        # Aller chercher les AD qui sont affectées
            ad_affectee = entite_intersect_buffer(buffer, couche_recens, ['ADIDU'])
            #print(ad_affectee)

        # Aller chercher la population totale affectée dans le CSV en entrée
            import csv
            path_csv = r'{}'.format(recens_text)

            dic_pop = {}
            # on ouvre le fichier CSV des AD e spécifiant l'encodage à ISO-8859-1 pour gérer les caractères spéciaux
            with open(path_csv, encoding='ISO-8859-1') as csv_file:
                # On crée le reader qui va permettre de parcourir les row comme des dictionnaires
                csv_reader = csv.DictReader(csv_file)
                # On parcours chaque row du fichier
                for row in csv_reader:
                    for i in ad_affectee:
                        for j in i.values():
                            # Si le ID du row égal un ID dans la liste des AD affectées, on ajoute la pop. du row
                            # avec son ID au dictionnaire
                            if row['ADidu'] == j:
                                dic_pop.update({j: int(row['ADpop_2016'])})
            #print(dic_pop)
            # On additionne toutes les populations du dictionnaire pour trouver la pop. totale
            pop_totale = sum(dic_pop.values())

        # Aller chercher les rues qui sont affectées
            rue_affectee = entite_intersect_buffer(buffer, couche_route, ['CLASSE', 'TYP_VOIE', 'NOM_VOIE'])

        # Aller chercher les adresses affectées
            adr_affectee = entite_intersect_buffer(buffer, couche_adresse, ['ID_ADRESSE', 'TEXTE','SPECIFIQUE','GENERIQUE', 'GEOMETRY'])

        # Aller chercher l'adresse la plus proche
            dis = QgsDistanceArea()
            # On déclare les entités de la couche du point incident
            featInc = couche_point.getFeatures()
            # On parcours les entités de la couche du point incident
            for pointInc in featInc:
                # On déclare le geom de l'entité comme un point
                geomInc = pointInc.geometry().asPoint()
                # On parcours la liste des adresses affectées
                for adr in adr_affectee:
                    # On déclare le geom de l'adresses affectées comme un points
                    geomAdr = adr['GEOMETRY'].asPoint()
                    # On calcule la distance entre le point incident et l'adresse affectée
                    distance = dis.measureLine(geomInc, geomAdr)
                    # On ajoute la distance comme attribut dans le dictionnaire de l'adresse
                    adr['DIST'] = distance

            # On tri la liste des adresses affectées selon la distance
            sort_adr_aff_distance = sorted(adr_affectee, key=lambda i: i['DIST'])
            # On récupère l'adresse ayant la distance la plus courte
            adr_plus_proche = sort_adr_aff_distance[0]


        # Afficher les informations dans la console
            # Population totale
            print('La population totale affectée est de : {} personnes'.format(pop_totale))

            # Rues affectées
            liste_rue_unique =[]
            for rue in rue_affectee:
                if rue not in liste_rue_unique:
                    liste_rue_unique.append(rue)
            sort_rue_aff = sorted(liste_rue_unique, key=lambda i: (i['CLASSE'], i['NOM_VOIE']))
            print('Les rues affectées sont:')
            for r in sort_rue_aff:
                print('nom: {}'.format(r['NOM_VOIE']), 'Type: {}'.format(r['TYP_VOIE']))

            # Adresse la plus proche de l'incident
            print("L'adresse la plus proche de l'incident est: {} {} {}"
                    .format(adr_plus_proche['TEXTE'], adr_plus_proche['GENERIQUE'], adr_plus_proche['SPECIFIQUE']))
            print('Distance: {:.2f} m'.format(adr_plus_proche['DIST']))

        # Création du fichier de sortie
            path_output = r'C:\Users\home\Documents\Documents\Géoinformatique 2\GMQ580_TD2\output.txt'
            f = open(path_output, 'w')

            f.write('****************************************************\n')
            f.write("RÉSULTATS DE L'ANALYSE DE L'OUTIL'INCENDIEMONTREAL'\n")
            f.write('****************************************************\n')
            f.write('\n')

            # Population totale
            f.write('La population totale affectée est de : {} personnes\n'.format(pop_totale))
            f.write('\n')

            # Rues affectées et adresses
            count = 0
            f.write('Les adresses affectées ainsi que leur rue respective sont:\n')
            f.write('\n')
            for r in sort_rue_aff:
                f.write('NOM: {} TYPE: {}\n'.format(r['NOM_VOIE'],r['TYP_VOIE']))
                for a in adr_affectee:
                    if str(a['SPECIFIQUE']).lower() == str(r['NOM_VOIE']).lower() and str(a['GENERIQUE']).lower() == str(r['TYP_VOIE']).lower():
                        f.write('{} {} {}\n'.format(a['TEXTE'], a['GENERIQUE'], a['SPECIFIQUE']))
                        count += 1
                f.write('\n')

            # Adresse la plus proche de l'incident
            f.write("L'adresse la plus proche de l'incident est: {} {} {}\n"
              .format(adr_plus_proche['TEXTE'], adr_plus_proche['GENERIQUE'], adr_plus_proche['SPECIFIQUE']))
            f.write('Distance: {:.2f} m'.format(adr_plus_proche['DIST']))
            # Fin du document
            f.write('\n')
            f.write('***************************************************\n')
            f.write('FIN DES RÉSULTATS\n')
            f.write('***************************************************\n')
            f.close()



            # count = 0
            # print('Les rues affectées sont:')
            # for r in sort_rue_aff:
            #     print('nom: {}'.format(r['NOM_VOIE']), 'Type: {}'.format(r['TYP_VOIE']))
            #     for a in adr_affectee:
            #         if a['SPECIFIQUE'] == r['NOM_VOIE'] and a['GENERIQUE'] == r['TYP_VOIE']:
            #             print(a['TEXTE'], a['GENERIQUE'], a['SPECIFIQUE'])
            #             count += 1
            # print('nombre total adresses: {}'.format(len(adr_affectee)))
            # print('nombre adresses printées: {}'.format(count))



            # 1. Faire le buffer sur la couche point
            # 2. Comptabiliser la population totale
            #   2.1 Faire une requête dans le CSV des AD avec les ID des AD à l'intérieur du buffer
            #   2.2 Extraire la population, faire le total
            # 3. Faire la liste des rues affectées
            #   3.1 Faire une requête dans la couche des rues, ceux qui sont contenues dans le buffer
            #   3.2 Ajouter les noms de rue à une liste
            # 4. Faire un dictionnaire des adresses affectées
            #   4.1 Faire une requête dans la couche des adresses, ceux qui sont contenues dans le buffer
            #   4.2 Ajouter les adresses comme key au dict.
            #   4.3 Extraire le nom de la rue et l'ajouter comme valeur au dictionnaire
            # 5. Formatage du fichier txt en sortie
            #   - on affiche la population totale affectée en haut du fichier
            #   - on affiche une rue
            #   - on affiche toutes les adresses affectées dans la rue
            # 6. Sauvegarde du fichier dans le répertoire spécifié

            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass
